<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Any → ForeFlight (DDM)</title>
  <meta name="description" content="Paste almost any coordinate format (DD, DDM, DMS) and get ForeFlight-ready DDM." />
  <style>
    :root { --brand:#0b3d91; --bg:#f6f8fb; --ink:#0b1220; --muted:#5b6573; --card:#fff; --ring:rgba(11,61,145,.2); }
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink)}
    .wrap{max-width:880px;margin:0 auto;padding:24px 16px 56px}
    h1{font-size:clamp(22px,4vw,34px);margin:.2em 0 .4em}
    p.hint{color:var(--muted);margin:.2em 0 1em}
    textarea{width:100%;min-height:200px;padding:14px 16px;border:1px solid #d7dce3;border-radius:12px;background:var(--card);font:16px/1.45 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;box-sizing:border-box}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    button{background:var(--brand);color:#fff;border:0;border-radius:12px;padding:12px 16px;font-weight:600;font-size:16px}
    button.secondary{background:#e8ecf5;color:#0b3d91}
    button:active{transform:translateY(1px)}
    .out{margin-top:16px;padding:14px 16px;border:1px solid #d7dce3;border-radius:12px;background:#fff;font:15px/1.5 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;white-space:pre-wrap}
    .muted{color:var(--muted);margin-top:8px}
    .small{font-size:13px;color:var(--muted)}
    .badge{display:inline-block;font-size:12px;font-weight:700;background:#eef3ff;color:var(--brand);padding:2px 8px;border-radius:9999px;margin-left:6px}
    .ok{border-left:6px solid #26a269}
    .warn{border-left:6px solid #e6a700}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Any → ForeFlight (DDM) <span class="badge">auto‑detect</span></h1>
    <p class="hint">Accepts most common formats (DD, DDM, DMS) with <span class="mono">N/S/E/W</span> or signs. One pair per line. Example inputs:</p>
    <ul class="small">
      <li class="mono">46.6205, -122.3493</li>
      <li class="mono">N46° 37.230', W122° 20.958'</li>
      <li class="mono">46 37 13.8 N, 122 20 57.5 W</li>
      <li class="mono">46 37.230 -122 20.958</li>
      <li class="mono">N46.6205 W122.3493</li>
    </ul>

    <textarea id="inp" placeholder="Paste coordinates here..."></textarea>

    <div class="row">
      <button id="convert" type="button">Convert</button>
      <button id="copy" type="button" class="secondary">Copy output</button>
      <button id="test" type="button" class="secondary">Paste test set</button>
      <button id="clear" type="button" class="secondary">Clear</button>
    </div>

    <div id="out" class="out" aria-live="polite"></div>
    <div class="small muted" id="foot"></div>
  </div>

<script>
(function(){
  // ---------- helpers ----------
  function normalize(s){
    if (!s) return "";
    return s
      // normalize unicode minus variants to hyphen
      .replace(/[\\u2212\\u2012\\u2013\\u2014\\u2015\\uFE63\\uFF0D]/g,"-")
      // normalize degree/minute/second glyphs
      .replace(/[dD][eE][gG]/g, "°")
      .replace(/[º]/g, "°")
      .replace(/[′’`]/g, "'")
      .replace(/[“”]/g, '"')
      // commas/semicolons/pipe -> comma
      .replace(/[;|]/g, ",")
      // collapse whitespace
      .replace(/\\s+/g, " ")
      .trim();
  }

  function extractNumbers(s){
    const m = s.match(/[+-]?\\d+(?:\\.\\d+)?/g);
    return m ? m.map(Number) : [];
  }

  function hasLatHemi(s){ return /[NS]/i.test(s); }
  function hasLonHemi(s){ return /[EW]/i.test(s); }
  function hemiSign(s){
    const m = s.match(/[NSEW]/i);
    if (!m) return null;
    const h = m[0].toUpperCase();
    if (h==="S" || h==="W") return -1;
    return 1;
  }

  function toDecimalFromParts(parts){
    const [deg, min, sec] = parts;
    let d = Math.abs(deg);
    if (typeof min === "number") d += Math.abs(min)/60;
    if (typeof sec === "number") d += Math.abs(sec)/3600;
    return d;
  }

  function parseSingleCoord(chunk, expectLat){
    const raw = chunk;
    const s = normalize(chunk).toUpperCase();
    if (!s) return { ok:false, err:"empty", raw };

    const nums = extractNumbers(s);
    if (nums.length === 0) return { ok:false, err:"no numbers", raw };

    // Determine sign from hemisphere or explicit minus on first number
    let sign = 1;
    const hsign = hemiSign(s);
    if (hsign) sign = hsign;
    if (/^-/.test(s.trim())) sign = -1; // leading negative

    let value;
    if (nums.length >= 3){
      // DMS
      const [deg, min, sec] = nums;
      if (min >= 60 || sec >= 60) return { ok:false, err:"minutes/seconds out of range", raw };
      value = toDecimalFromParts([deg, min, sec]);
    } else if (nums.length === 2){
      // DDM
      const [deg, min] = nums;
      if (min >= 60) return { ok:false, err:"minutes out of range", raw };
      value = toDecimalFromParts([deg, min]);
    } else {
      // DD
      const [deg] = nums;
      value = Math.abs(deg);
      // If the sign is from DD itself (e.g., -122.3), honor it:
      if (deg < 0) sign = -1;
    }
    value = sign * value;

    // Range check
    const lim = expectLat ? 90 : 180;
    if (Math.abs(value) > lim + 1e-9){
      return { ok:false, err:"degrees out of range", raw };
    }
    return { ok:true, val:value, raw, type: (nums.length>=3?"DMS":(nums.length===2?"DDM":"DD")), sign };
  }

  function splitIntoPair(line){
    const s = normalize(line);
    if (!s) return null;

    // 1) comma preferred
    const parts = s.split(",");
    if (parts.length >= 2){
      const a = parts[0].trim();
      const b = parts.slice(1).join(",").trim(); // in case seconds contained commas earlier
      if (a && b) return [a,b];
    }

    // 2) both hemispheres present
    // try "NS ...  EW ..." or "EW ...  NS ..."
    let m = s.match(/^(.*?[NS][^NSEW]*?)\\s+(.*?[EW][^NSEW]*?)$/i);
    if (m) return [m[1].trim(), m[2].trim()];
    m = s.match(/^(.*?[EW][^NSEW]*?)\\s+(.*?[NS][^NSEW]*?)$/i);
    if (m) return [m[2].trim(), m[1].trim()]; // reorder: lat first

    // 3) fallback: split by two large numeric clusters
    const clusters = s.match(/([NSEW]?\\s*[+-]?\\d[^,]*?(?:\"|\\'|°)?)(?:\\s+|$)/ig);
    if (clusters && clusters.length >= 2){
      return [clusters[0].trim(), clusters[1].trim()];
    }

    return null;
  }

  function formatDDM(decDeg, isLat){
    const hemi = decDeg >= 0 ? (isLat ? "N" : "E") : (isLat ? "S" : "W");
    const abs = Math.abs(decDeg);
    let deg = Math.floor(abs);
    let minutes = (abs - deg) * 60;

    // Round to 3 decimals and handle 59.999 -> 60.000 rollover
    minutes = Math.round(minutes * 1000) / 1000;
    if (minutes >= 60){
      deg += 1;
      minutes = 0;
    }

    const degWidth = isLat ? 2 : 3;
    const dStr = String(deg).padStart(degWidth, "0");
    const mStr = minutes.toFixed(3).padStart(6, "0"); // ensures 0 leading if < 10
    return `${hemi}${dStr}° ${mStr}'`;
  }

  function convertAll(text){
    const lines = text.split(/\\r?\\n/);
    const out = [];
    let total = 0, ok = 0, bad = 0;

    for (const raw of lines){
      const line = raw.trim();
      if (!line) continue;
      total++;

      const pair = splitIntoPair(line);
      if (!pair){
        out.push(`⚠️ Couldn't find a lat,lon pair:  ${raw}`);
        bad++; continue;
      }

      // Guess ordering: lat first, unless hemispheres make it obvious
      let [latChunk, lonChunk] = pair;

      // If first chunk looks like E/W and second N/S, swap
      if (/[EW]/i.test(latChunk) && /[NS]/i.test(lonChunk)){
        [latChunk, lonChunk] = [lonChunk, latChunk];
      }

      const plat = parseSingleCoord(latChunk, true);
      const plon = parseSingleCoord(lonChunk, false);

      if (!plat.ok || !plon.ok){
        const why = !plat.ok ? `lat: ${plat.err}` : `lon: ${plon.err}`;
        out.push(`⚠️ Parse error (${why}):  ${raw}`);
        bad++; continue;
      }

      // final format (ForeFlight DDM)
      const latDDM = formatDDM(plat.val, true);
      const lonDDM = formatDDM(plon.val, false);
      out.push(`${latDDM} ${lonDDM}`);
      ok++;
    }

    return { text: out.join("\\n"), stats: { total, ok, bad } };
  }

  // ---------- UI ----------
  const $ = (id)=>document.getElementById(id);
  const inp = $("inp");
  const out = $("out");
  const foot = $("foot");

  function run(){
    const res = convertAll(inp.value);
    out.className = "out" + (res.stats.bad ? " warn" : " ok");
    out.textContent = res.text || "No lines to process.";
    foot.textContent = `${res.stats.ok} converted, ${res.stats.bad} skipped — ${res.stats.total} line(s) processed.`;
  }

  $("convert").addEventListener("click", run);
  $("clear").addEventListener("click", ()=>{ inp.value=""; out.textContent=""; foot.textContent=""; });
  $("copy").addEventListener("click", async ()=>{
    try {
      await navigator.clipboard.writeText(out.textContent);
      $("copy").textContent = "Copied!";
      setTimeout(()=> $("copy").textContent = "Copy output", 1000);
    } catch(e){
      alert("Copy failed. Select and copy manually.");
    }
  });
  $("test").addEventListener("click", ()=>{
    const tests = [
      "46.6205, -122.3493",
      "N46° 37.230', W122° 20.958'",
      "46 37 13.8 N, 122 20 57.5 W",
      "46 37.230, -122 20.958",
      "N46.6205 W122.3493",
      "S34 03.500, E018 27.250",
      "34°03'30\"N 118°14'37.2\"W",
      "47.6205 -122.3493",
      "N47 37.230 W122 20.958",
      "47° 37.230' N 122° 20.958' W"
    ].join("\\n");
    inp.value = tests;
  });

  // Autofill example on load (keeps it blank if input already has text)
  if (!inp.value) inp.value = "46.6205, -122.3493\\nN46° 37.230', W122° 20.958'";

  // Allow pressing Enter+Cmd/Ctrl to convert
  inp.addEventListener("keydown", (e)=>{
    if ((e.metaKey || e.ctrlKey) && e.key === "Enter") { run(); }
  });
})();
</script>

</body>
</html>
