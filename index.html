<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DDM → ForeFlight Converter</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0b3d91">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<link rel="apple-touch-icon" href="icons/apple-touch-icon-180.png">
<style>
  body {
    font-family: sans-serif;
    margin: 20px;
    background: #f9f9f9;
  }
  h1 { font-size: 1.4em; }
  input, button {
    font-size: 1.1em;
    padding: 8px;
    margin: 6px 0;
    width: 100%;
    box-sizing: border-box;
  }
  button {
    background: #0b3d91;
    color: white;
    border: none;
    cursor: pointer;
  }
  pre {
    background: #fff;
    padding: 10px;
    border: 1px solid #ccc;
    font-size: 1.2em;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
</style>
</head>
<body>

<h1>DDM → ForeFlight Converter</h1>

<!-- Option A: Two separate inputs -->
<input id="lat" placeholder="Latitude (any format)">
<input id="lon" placeholder="Longitude (any format)">

<!-- OR Option B: Single combined input -->
<input id="combined" placeholder="Paste both lat/lon (any format)">

<button onclick="handleConvertClick()">Convert</button>

<pre id="output"></pre>

<script>
// === Any format in -> ForeFlight DDM out ===
// Accepts DMS / DDM / Decimal Degrees. Robust to symbols, spacing, and hemisphere position.

const BASE_LAT_MAX = 90;
const BASE_LON_MAX = 180;

function normalize(str) {
  return (str || '')
    .trim()
    .replace(/[“”]/g, '"')
    .replace(/[′’]/g, "'")
    .replace(/[º˚ﹾ]/g, '°')
    .replace(/\s+/g, ' ')
    .toUpperCase();
}

function splitLatLon(raw) {
  const s = normalize(raw);
  const sepMatch = s.split(/[,;/]|(?:\s{2,})/).map(t => t.trim()).filter(Boolean);
  if (sepMatch.length >= 2) return [sepMatch[0], sepMatch[1]];
  const tokens = s.split(/\s/);
  const idxN = tokens.findIndex(t => /[NS]/.test(t));
  const idxE = tokens.findIndex(t => /[EW]/.test(t));
  if (idxN !== -1 && idxE !== -1) {
    const i1 = Math.min(idxN, idxE);
    const i2 = Math.max(idxN, idxE);
    return [tokens.slice(0, i2 + 1).join(' '), tokens.slice(i2 + 1).join(' ')];
  }
  return [s, null];
}

function parseAnyCoord(input, isLat = null) {
  const s = normalize(input);
  if (!s) throw new Error('Empty coordinate');
  let hemi = (s.match(/[NSEW]/) || [null])[0];
  let sign = 1;
  if (!hemi && /^\s*-/.test(s)) sign = -1;
  const nums = (s.match(/-?\d+(?:\.\d+)?/g) || []).map(parseFloat);
  const hasDegSym = /°/.test(s);
  if (nums.length >= 3) {
    const [degRaw, minRaw, secRaw] = nums;
    const deg = Math.abs(degRaw);
    const minutes = Math.abs(minRaw) + Math.abs(secRaw) / 60;
    return { deg, minutes, hemi, sign: hemi ? signFromHemi(hemi, isLat) : (degRaw < 0 ? -1 : sign) };
  } else if (nums.length === 2) {
    const [degRaw, minRaw] = nums;
    const deg = Math.abs(degRaw);
    const minutes = Math.abs(minRaw);
    return { deg, minutes, hemi, sign: hemi ? signFromHemi(hemi, isLat) : (degRaw < 0 ? -1 : sign) };
  } else if (nums.length === 1) {
    const dec = nums[0];
    const { deg, minutes } = decDegToDDM(Math.abs(dec));
    return { deg, minutes, hemi, sign: hemi ? signFromHemi(hemi, isLat) : (dec < 0 ? -1 : 1) };
  }
  throw new Error('Unable to parse coordinate: ' + input);
}

function signFromHemi(hemi, isLat) {
  if (hemi === 'N') return 1;
  if (hemi === 'S') return -1;
  if (hemi === 'E') return 1;
  if (hemi === 'W') return -1;
  return isLat ? 1 : 1;
}

function decDegToDDM(dec) {
  const deg = Math.floor(dec);
  const minutes = (dec - deg) * 60;
  return { deg, minutes };
}

function formatDDM({ deg, minutes, hemi, sign }, isLat) {
  if (!hemi) hemi = isLat ? (sign < 0 ? 'S' : 'N') : (sign < 0 ? 'W' : 'E');
  deg = Math.abs(deg);
  minutes = Math.abs(minutes);
  if (minutes >= 59.9995) { deg += 1; minutes = 0; }
  const degWidth = isLat ? 2 : 3;
  const degStr = String(deg).padStart(degWidth, '0');
  const minStr = minutes.toFixed(3).padStart(6, '0');
  return `${degStr}° ${minStr}' ${hemi}`;
}

function inferAxis(parsedLat, parsedLon) {
  let lat = parsedLat, lon = parsedLon;
  if (lat && lon) {
    const latLooksLikeLat = (lat.hemi ? /[NS]/.test(lat.hemi) : lat.deg <= BASE_LAT_MAX);
    const lonLooksLikeLon = (lon.hemi ? /[EW]/.test(lon.hemi) : lon.deg <= BASE_LON_MAX && lon.deg > BASE_LAT_MAX);
    if (!latLooksLikeLat && lonLooksLikeLon) [lat, lon] = [lon, lat];
  }
  return { lat, lon };
}

function convertToForeFlightDDM(latStr, lonStr) {
  if (!latStr) throw new Error('Latitude missing');
  if (!lonStr) throw new Error('Longitude missing');
  let lat = parseAnyCoord(latStr, true);
  let lon = parseAnyCoord(lonStr, false);
  ({ lat, lon } = inferAxis(lat, lon));
  if (lat.deg > BASE_LAT_MAX) throw new Error('Latitude degrees out of range');
  if (lon.deg > BASE_LON_MAX) throw new Error('Longitude degrees out of range');
  return `${formatDDM(lat, true)}, ${formatDDM(lon, false)}`;
}

function convertCombinedInput(raw) {
  const [latStr, lonStr] = splitLatLon(raw);
  if (!lonStr) throw new Error('Could not detect both Lat and Lon; add a comma or space between them.');
  return convertToForeFlightDDM(latStr, lonStr);
}

function handleConvertClick() {
  const latEl = document.querySelector('#lat');
  const lonEl = document.querySelector('#lon');
  const combinedEl = document.querySelector('#combined');
  const out = document.querySelector('#output');
  try {
    let result;
    if (combinedEl && combinedEl.value.trim()) {
      result = convertCombinedInput(combinedEl.value);
    } else {
      result = convertToForeFlightDDM(latEl.value, lonEl.value);
    }
    out.textContent = result;
  } catch (e) {
    out.textContent = e.message;
  }
}
</script>

</body>
</html>
